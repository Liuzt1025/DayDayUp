## 类的this指针

类的成员函数通过this指针隐式地访问类中的所有成员，基于这一点，类的成员函数和普通函数有一个明显的区别，那就是这个函数包含一个隐式的this指针。并且this指针的类型为：

```c++
class A{
	// this的类型为const A*
}
```

有的时候，为了实现链式调用，函数通常返回*this。

```c++
class A{
public:
    A(int n) : a_(n) {}
    int a_;
    A& add(const A& B){
        this->a_ += B.a_;
        return *this;
    }
};

int main(){
    A a1(10), a2(20), a3(30);
    a1.add(a2).add(a3);
    cout << a1.a_ << endl;	// a = 60
    return 0;
}
```

## const成员函数

有的时候我们经常见到const加在函数参数列表后面，这个就是const成员函数，也叫做常成员函数。例如：

```c++
class A{
	A& add(const A& a, const A&b) const {}
}
```

const成员函数中的this指针是指向常量的指针。也就是:

```
class A{
	A& add(const A& a, const A&b) const {}
	// this的类型为 const A const &
}
```

因此，const成员函数与普通成员函数的区别在于：const成员函数中不能修改类的数据成员(因为成员函数中是通过this指针访问类的成员的)。

**note:如果一个类是const(包括引用和指针)，那么只能调用它的常成员函数。**



const成员函数可以与非const成员函数重载

## 类的作用域运算符：：

通过类的作用域运算符，可以访问到类的作用域内部。

```c++
class A{	// 类的作用域从这个地方开始
	...
};	// 到这个地方结束
```

通过在类外面包含类的作用域：

```c++
class A{
	...
};

//通过作用域运算符在类外面定义类的成员函数
A& A::add(const A&){...}
```



## 类的构造函数

类的构造函数有以下几个特点：

- 与类同名，并且可能包含0到多个参数。
- 只要类被创建，那么就执行构造函数。

**note:构造函数一般都会修改类的数据成员，因此不能将类设置为const**



### 类的默认初始化

#### 1、对于内置类型

当一个内置类型定义了，但是没有提供初始值，那么就会指向默认初始化。

默认初始化的结果取决于该类型的属性。

```c++
int a;
int main(){
	cout << a << endl; // a的输出为0，a是一个全局变量，位于内存中的全局区
	int b;
	cout << b << endl;	// 其结果未定义
	return 0;
}
```

#### 2、对于类的数据成员

对于类的数据成员，没有提供默认的构造函数时，编译器自己合成默认构造函数。

默认构造函数对数据成员的初始化规则:

​	1、如果提供初始值，那么使用初始值初始化数据成员。

​	2、如果没有提供初始值，那么使用以上的默认初始化规则.

```c++
class tmp{
public:
    tmp() = default;
    int *p;
    int a = 15;
};

tmp a;
int main(){
    tmp b;
    
    cout << b.p << endl;	// 未定义 
    cout << a.p << endl;	// nullptr
    
    cout << a.a << endl;	// 15
    cout << b.a << endl;	// 15
    
    return 0;
}
```



